原因判断在两个地方：
一个在_get_prune_reason这个函数中，不需要排序的。
一个在 if full_log: 这个分支里面，需要排序的。

整体思路是：

1、每个迭代都记录相关的数据

2、只有到第十轮才会记录相关日志及其原因

3、然后在所有活跃的id中，根据相关原因计算可疑得分，
如果suspicious_score大于等于1（这项可调整），就被记作可疑点

具体每个原因的思路：
1、color_jitter:
首先将球谐函数转换为rgb颜色，然后prev_rgb_dict中的进行比较，计算相关两轮之间的颜色delta。
 topk = max(1, int(0.05 * num_points))
然后在每个full-log里面记录排序前topk个颜色变化的高斯球
算作color_jitter
2、fast_motion:
步骤与上面完全相同，每次直接用pos和prev_pos_dict比较记录delta
3、elongated
取scale（表示高斯球在xyz上的膨胀大小）中的最大值和最小值的比值，取topK，算作有问题的。
4、isloated：
使用KD-tree相关的库计算邻近距离，取topK，算作有问题的。
5、fake-floater：
根据scale计算体积，通过透明度除以体积得到密度，再用密度乘透明度得到投影强度strength, 如果投影强度大于150且是hit_counts少则是有问题的
6、transparency:
透明度太低（小于0.01)则是有问题的
7、overscaled
根据我的观察大部分的scale列表每个参数都是小于3的，如果说有一个大于3则算是有问题的。
8、sudden_rise:
利用z_history记录最近z_window_size个数目的z值，根据3sigma原理如果不在3sigma区间内就认为是sudden_rise
9、low_visibilty:
取最近十次，如果说low_hits超过八次则认为是low_visibility:


整体tracker的核心是在update函数中：
主要分为 
1、基本的初始化获取参数
2、因为涉及高斯球的变动，统计活跃的id序号（这步是必要的因为，有可能删减增加之后高斯球的id编号和给过来的参数下标不相等。
3、计算必要的日志数据，但不写入日志
4、full_log为true时：计算相关，写入日志。